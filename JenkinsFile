pipeline {
    agent any

    tools {
        maven 'Maven 3.8.6'
        jdk 'JDK 17'
    }

    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['staging', 'production'], description: 'Select deployment environment')
        string(name: 'SERVER_PORT', defaultValue: '8081', description: 'Port for the application to run on server')
        string(name: 'MYSQL_PORT', defaultValue: '3306', description: 'Port for MySQL to run on server')
    }

    environment {
        AWS_CREDENTIALS = credentials('aws-credentials')
        MAIL_CREDENTIALS = credentials('mail-credentials')
        JWT_SECRET = credentials('jwt-secret')
        DB_CREDENTIALS = credentials('db-credentials')
        MYSQL_ROOT_PASSWORD = credentials('mysql-root-password')
        DOCKER_CREDENTIALS = credentials('docker-hub-credentials')
        UNIVERSITY_CREDENTIALS = credentials('university-server-credentials')
        UNIVERSITY_SERVER = credentials('university-server-ip')
        DOCKER_IMAGE = "jathurt/myapp-backend"
        DEPLOY_ENV = "${params.DEPLOY_ENV ?: 'staging'}"
        SERVER_PORT = "${params.SERVER_PORT}"
        MYSQL_PORT = "${params.MYSQL_PORT}"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Build') {
            steps {
                sh 'chmod +x mvnw'
                sh './mvnw clean package -DskipTests --no-transfer-progress'
            }
        }

        stage('Test') {
            steps {
                withEnv([
                    'SPRING_PROFILES_ACTIVE=test',
                    'SPRING_DATASOURCE_URL=jdbc:h2:mem:testdb',
                    'SPRING_DATASOURCE_USERNAME=sa',
                    'SPRING_DATASOURCE_PASSWORD=',
                    'SPRING_JPA_HIBERNATE_DDL_AUTO=create-drop'
                ]) {
                    sh './mvnw test'
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

        stage('Prepare .env File') {
            steps {
                script {
                    sh '''
                        # Create .env file with secure permissions
                        touch .env && chmod 600 .env

                        cat > .env << EOL
SPRING_APPLICATION_NAME=backend
SERVER_PORT=${SERVER_PORT}
MYSQL_PORT=${MYSQL_PORT}
MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
SPRING_JPA_HIBERNATE_DDL_AUTO=update
SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/dental
SPRING_DATASOURCE_USERNAME=${DB_CREDENTIALS_USR}
SPRING_DATASOURCE_PASSWORD=${DB_CREDENTIALS_PSW}
SPRING_DATASOURCE_DRIVER_CLASS_NAME=com.mysql.cj.jdbc.Driver
SPRING_JPA_SHOW_SQL=false
APP_CORS_ALLOWED_ORIGINS=*
APP_RESET_PASSWORD_LINK=http://myapp.com/reset-password
SPRING_APP_JWTSECRET=${JWT_SECRET}
SPRING_APP_JWTEXPIRATIONMS=86400000
SPRING_APP_JWTCOOKIENAME=dn-dental-clinic
SPRING_MAIL_HOST=smtp.gmail.com
SPRING_MAIL_PORT=587
SPRING_MAIL_USERNAME=${MAIL_CREDENTIALS_USR}
SPRING_MAIL_PASSWORD=${MAIL_CREDENTIALS_PSW}
SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH=true
SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE=true
SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_REQUIRED=true
SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT=5000
SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT=5000
SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT=5000
AWS_ACCESSKEYID=${AWS_CREDENTIALS_USR}
AWS_SECRETKEY=${AWS_CREDENTIALS_PSW}
AWS_REGION=eu-north-1
AWS_S3_BUCKET=patient-logbook-photos
EOL

                        # Verify file was created successfully
                        if [ ! -f .env ]; then
                            echo "Failed to create .env file"
                            exit 1
                        fi
                    '''
                }
            }
        }

        stage('Check Monitoring Directories') {
            steps {
                script {
                    sh '''
                        # Verify that the required directories exist
                        if [ ! -d "prometheus" ]; then
                            echo "Error: prometheus directory not found in project"
                            exit 1
                        fi

                        if [ ! -d "grafana/provisioning/dashboards" ]; then
                            echo "Error: grafana/provisioning/dashboards directory not found in project"
                            exit 1
                        fi

                        if [ ! -d "grafana/provisioning/datasources" ]; then
                            echo "Error: grafana/provisioning/datasources directory not found in project"
                            exit 1
                        fi

                        # Verify the directories contents
                        ls -la prometheus/
                        ls -la grafana/provisioning/dashboards/
                        ls -la grafana/provisioning/datasources/
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh "docker build -t ${DOCKER_IMAGE}:${BUILD_NUMBER} ."
                    sh "docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest"
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                sh 'echo $DOCKER_CREDENTIALS_PSW | docker login -u $DOCKER_CREDENTIALS_USR --password-stdin'
                sh "docker push ${DOCKER_IMAGE}:${BUILD_NUMBER}"
                sh "docker push ${DOCKER_IMAGE}:latest"
            }
        }

        stage('Prepare Deployment Files') {
            steps {
                script {
                    // Create a shell script to handle SSH/SCP using sshpass
                    writeFile file: 'deploy.sh', text: """#!/bin/bash
set -e

# Check if sshpass is installed
if ! command -v sshpass &> /dev/null; then
    echo "sshpass is not installed. Installing..."
    apt-get update && apt-get install -y sshpass
fi

# Export variables for use in sshpass
export SSHPASS="${UNIVERSITY_CREDENTIALS_PSW}"

# Create remote directories
sshpass -e ssh -o StrictHostKeyChecking=no ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER} "mkdir -p ~/app-deployment/prometheus ~/app-deployment/grafana/provisioning/dashboards ~/app-deployment/grafana/provisioning/datasources"

# Copy files using sshpass
sshpass -e scp -o StrictHostKeyChecking=no docker-compose.yml .env ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/
sshpass -e scp -o StrictHostKeyChecking=no -r prometheus/* ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/prometheus/
sshpass -e scp -o StrictHostKeyChecking=no -r grafana/provisioning/dashboards/* ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/grafana/provisioning/dashboards/
sshpass -e scp -o StrictHostKeyChecking=no -r grafana/provisioning/datasources/* ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/grafana/provisioning/datasources/

# Create remote deployment script
cat > remote_deploy.sh << EOL
#!/bin/bash
set -e

cd ~/app-deployment

# Docker login
echo "${DOCKER_CREDENTIALS_PSW}" | docker login --username "${DOCKER_CREDENTIALS_USR}" --password-stdin

# Stop any existing services
docker-compose down --remove-orphans || true

# Clean up stale containers
docker ps -aq | xargs docker rm -f 2>/dev/null || true
docker network prune -f || true

# Pull latest images
docker-compose pull

# Start services
docker-compose up -d

# Check if services started successfully
if ! docker-compose ps | grep -q "Up"; then
    echo "Containers failed to start properly"
    docker-compose logs
    exit 1
fi

echo "Deployment completed successfully!"
EOL

# Copy and execute remote deployment script
sshpass -e scp -o StrictHostKeyChecking=no remote_deploy.sh ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/
sshpass -e ssh -o StrictHostKeyChecking=no ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER} "chmod +x ~/app-deployment/remote_deploy.sh && ~/app-deployment/remote_deploy.sh"

# Clean up local remote_deploy.sh
rm -f remote_deploy.sh
                    """

                    sh 'chmod +x deploy.sh'
                }
            }
        }

        stage('Deploy to University Server') {
            steps {
                script {
                    // Use withEnv to avoid exposing credentials directly
                    withEnv(["SSHPASS=${UNIVERSITY_CREDENTIALS_PSW}"]) {
                        // Try to install sshpass if needed using Jenkins user permissions
                        sh '''
                            if ! command -v sshpass &> /dev/null; then
                                echo "sshpass not found, attempting to install..."
                                # Try to install without sudo first
                                apt-get update && apt-get install -y sshpass || true

                                # If install failed and we're on a Debian/Ubuntu, try alternative paths
                                if ! command -v sshpass &> /dev/null; then
                                    # Try with apt-get with non-interactive
                                    DEBIAN_FRONTEND=noninteractive apt-get install -y sshpass || true
                                fi

                                # If still not installed, try to download and use precompiled binary
                                if ! command -v sshpass &> /dev/null; then
                                    echo "Attempting to download and use precompiled sshpass..."
                                    wget -q https://sourceforge.net/projects/sshpass/files/sshpass/1.09/sshpass-1.09.tar.gz
                                    tar -xzf sshpass-1.09.tar.gz
                                    cd sshpass-1.09
                                    ./configure && make
                                    cp sshpass ../
                                    cd ..
                                    SSHPASS_PATH="./sshpass"
                                else
                                    SSHPASS_PATH="sshpass"
                                fi
                            else
                                SSHPASS_PATH="sshpass"
                            fi

                            # Now use sshpass for deployment
                            export SSHPASS="${UNIVERSITY_CREDENTIALS_PSW}"

                            # Create remote directories
                            $SSHPASS_PATH -e ssh -o StrictHostKeyChecking=no ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER} "mkdir -p ~/app-deployment/prometheus ~/app-deployment/grafana/provisioning/dashboards ~/app-deployment/grafana/provisioning/datasources"

                            # Copy files using sshpass
                            $SSHPASS_PATH -e scp -o StrictHostKeyChecking=no docker-compose.yml .env ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/
                            $SSHPASS_PATH -e scp -o StrictHostKeyChecking=no -r prometheus/* ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/prometheus/
                            $SSHPASS_PATH -e scp -o StrictHostKeyChecking=no -r grafana/provisioning/dashboards/* ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/grafana/provisioning/dashboards/
                            $SSHPASS_PATH -e scp -o StrictHostKeyChecking=no -r grafana/provisioning/datasources/* ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/grafana/provisioning/datasources/

                            # Create and execute remote deployment script
                            echo '#!/bin/bash
set -e

cd ~/app-deployment

# Docker login
echo "${DOCKER_CREDENTIALS_PSW}" | docker login --username "${DOCKER_CREDENTIALS_USR}" --password-stdin

# Stop any existing services
docker-compose down --remove-orphans || true

# Clean up stale containers
docker ps -aq | xargs docker rm -f 2>/dev/null || true
docker network prune -f || true

# Pull latest images
docker-compose pull

# Start services
docker-compose up -d

# Check if services started successfully
if ! docker-compose ps | grep -q "Up"; then
    echo "Containers failed to start properly"
    docker-compose logs
    exit 1
fi

echo "Deployment completed successfully!"' > remote_deploy.sh

                            $SSHPASS_PATH -e scp -o StrictHostKeyChecking=no remote_deploy.sh ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER}:~/app-deployment/
                            $SSHPASS_PATH -e ssh -o StrictHostKeyChecking=no ${UNIVERSITY_CREDENTIALS_USR}@${UNIVERSITY_SERVER} "chmod +x ~/app-deployment/remote_deploy.sh && ~/app-deployment/remote_deploy.sh"

                            # Clean up
                            rm -f remote_deploy.sh
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                // Clean up Docker resources
                sh 'docker logout || true'
                sh 'docker system prune -f || true'

                // Remove sensitive files
                sh '''
                    rm -f .env
                    rm -f deploy.sh
                    rm -f ssh_config
                    rm -f sshpass
                    rm -f get-docker.sh || true
                    rm -rf sshpass-* || true
                '''

                cleanWs()
            }
        }
        success {
            echo "Successfully deployed to ${DEPLOY_ENV} environment at ${UNIVERSITY_SERVER}"
        }
        failure {
            echo "Deployment to ${DEPLOY_ENV} failed"
        }
    }
}