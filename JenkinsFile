pipeline {
    agent any

    tools {
        maven 'Maven 3.8.6'
        jdk 'JDK 17'
    }

    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['staging', 'production'], description: 'Select deployment environment')
        string(name: 'EC2_PORT', defaultValue: '8081', description: 'Port for the application to run on EC2')
    }

    environment {
        AWS_CREDENTIALS = credentials('aws-credentials')
        MAIL_CREDENTIALS = credentials('mail-credentials')
        JWT_SECRET = credentials('jwt-secret')
        DB_CREDENTIALS = credentials('db-credentials')
        DOCKER_CREDENTIALS = credentials('docker-hub-credentials')
        DOCKER_IMAGE = "jathurt/myapp-backend"
        EC2_HOST = credentials('ec2-host')
        EC2_USER = 'ubuntu'
        DEPLOY_ENV = "${params.DEPLOY_ENV ?: 'staging'}"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Init') {
            steps {
                milestone(ordinal: 1)
            }
        }

        stage('Build') {
            steps {
                sh 'chmod +x mvnw'
                sh './mvnw clean package -DskipTests --no-transfer-progress'
            }
        }

//         Uncomment the test stage if needed
        stage('Test') {
            steps {
                // Set up test environment variables
                withEnv([
                    'SPRING_PROFILES_ACTIVE=test',
                    'SPRING_DATASOURCE_URL=jdbc:h2:mem:testdb',
                    'SPRING_DATASOURCE_USERNAME=sa',
                    'SPRING_DATASOURCE_PASSWORD=',
                    'SPRING_JPA_HIBERNATE_DDL_AUTO=create-drop'
                ]) {
                    sh './mvnw test'
                }
            }
            post {
                always {
                    // Capture detailed test reports
                    sh 'find target/surefire-reports -name "*.txt" -exec cat {} \\;'
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

//         Uncomment the SonarQube analysis stage if needed
//         stage('SonarQube Analysis') {
//             steps {
//                 withSonarQubeEnv('SonarQube') {
//                     sh './mvnw sonar:sonar'
//                 }
//             }
//         }

        stage('Prepare .env File') {
            steps {
                script {
                    sh '''
                    cat > .env << EOL
SPRING_APPLICATION_NAME=backend
SERVER_PORT=8081
SPRING_JPA_HIBERNATE_DDL_AUTO=update
SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/dental
SPRING_DATASOURCE_USERNAME=${DB_CREDENTIALS_USR}
SPRING_DATASOURCE_PASSWORD=${DB_CREDENTIALS_PSW}
SPRING_DATASOURCE_DRIVER_CLASS_NAME=com.mysql.cj.jdbc.Driver
SPRING_JPA_SHOW_SQL=false
APP_CORS_ALLOWED_ORIGINS=*
APP_RESET_PASSWORD_LINK=http://myapp.com/reset-password
SPRING_APP_JWTSECRET=${JWT_SECRET}
SPRING_APP_JWTEXPIRATIONMS=86400000
SPRING_APP_JWTCOOKIENAME=dn-dental-clinic
SPRING_MAIL_HOST=smtp.gmail.com
SPRING_MAIL_PORT=587
SPRING_MAIL_USERNAME=${MAIL_CREDENTIALS_USR}
SPRING_MAIL_PASSWORD=${MAIL_CREDENTIALS_PSW}
SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH=true
SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE=true
SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_REQUIRED=true
SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT=5000
SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT=5000
SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT=5000
AWS_ACCESSKEYID=${AWS_CREDENTIALS_USR}
AWS_SECRETKEY=${AWS_CREDENTIALS_PSW}
AWS_REGION=eu-north-1
AWS_S3_BUCKET=patient-logbook-photos
EOL
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Build using the built JAR from Jenkins
                    sh "docker build -t ${DOCKER_IMAGE}:${BUILD_NUMBER} ."
                    sh "docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest"
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                sh 'echo $DOCKER_CREDENTIALS_PSW | docker login -u $DOCKER_CREDENTIALS_USR --password-stdin'
                sh "docker push ${DOCKER_IMAGE}:${BUILD_NUMBER}"
                sh "docker push ${DOCKER_IMAGE}:latest"
            }
        }

        stage('Deploy to EC2') {
            steps {
                script {
                    writeFile file: 'deploy.sh', text: '''#!/bin/bash
        set -e

        # Get parameters from environment
        DOCKER_IMAGE="$1"
        EC2_PORT="$2"

        echo "Pulling latest Docker image..."
        docker pull "${DOCKER_IMAGE}:latest"

        echo "Checking for existing container..."
        if docker ps -a | grep -q myapp-backend; then
            echo "Stopping and removing existing container..."
            docker stop myapp-backend || true
            docker rm myapp-backend || true
        fi

        echo "Starting new container..."
        docker run -d \
            --name myapp-backend \
            --restart unless-stopped \
            -p "${EC2_PORT}:8081" \
            --env-file .env \
            "${DOCKER_IMAGE}:latest"

        echo "Waiting for container health check..."
        sleep 10

        echo "Checking container status..."
        if [ "$(docker ps -q -f name=myapp-backend)" ]; then
            echo "Container is running successfully"
        else
            echo "Container failed to start"
            exit 1
        fi
        '''

                    sh 'chmod +x deploy.sh'

                    sshagent(['ec2-ssh-key']) {
                        // First ensure docker permissions are set up correctly
                        sh """
                            ssh -o StrictHostKeyChecking=no \$EC2_USER@\$EC2_HOST '
                                # Add user to docker group if not already added
                                if ! groups \$USER | grep -q docker; then
                                    sudo usermod -aG docker \$USER
                                    echo "Added user to docker group. A reconnection may be required."
                                    # Create a new session to apply group changes
                                    exec sg docker -c "echo Docker group applied"
                                fi
                            '
                        """

                        // Copy files and execute deployment
                        sh """
                            scp -o StrictHostKeyChecking=no .env \$EC2_USER@\$EC2_HOST:/home/\$EC2_USER/
                            scp -o StrictHostKeyChecking=no deploy.sh \$EC2_USER@\$EC2_HOST:/home/\$EC2_USER/

                            ssh -o StrictHostKeyChecking=no \$EC2_USER@\$EC2_HOST '
                                chmod +x deploy.sh && \
                                sg docker -c "./deploy.sh \"${DOCKER_IMAGE}\" \"${params.EC2_PORT}\""
                            '
                        """
                    }
                }
            }
        }

    }

    post {
        always {
            sh 'docker logout'
            sh 'rm -f .env deploy.sh'
            cleanWs()
        }
        success {
            echo "Successfully deployed to ${DEPLOY_ENV} environment at ${EC2_HOST}"
        }
        failure {
            echo "Deployment to ${DEPLOY_ENV} failed"
        }
    }
}
